from typing import List, Optional

from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, Field
import logging

# -------------------------------------------------------------------
# Logging configuration (minimal; adjust handlers/format for real prod)
# -------------------------------------------------------------------
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Book Service",
    description="A simple production-style Book API using FastAPI",
    version="1.0.0",
)

# -------------------------------------------------------------------
# Pydantic Models
# -------------------------------------------------------------------

class BookBase(BaseModel):
    title: str = Field(min_length=5, description="Title of the book")
    author: str = Field(min_length=1, description="Author of the book")
    description: str = Field(
        min_length=1,
        max_length=200,
        description="Short description of the book",
    )
    rating: int = Field(gt=0, lt=6, description="Rating from 1 to 5")
    published_date: int = Field(
        gt=1999,
        lt=2030,
        description="Year in which the book was published",
    )
    price: float = Field(gt=0, description="Price of the book (in USD)")


class BookCreate(BookBase):
    # In many systems, id is generated by DB.
    # Keeping optional to match your original style.
    id: Optional[int] = Field(
        default=None,
        description="Book ID (optional; will be auto-assigned if missing)",
    )


class BookUpdate(BaseModel):
    """
    PATCH-style update: all fields optional.
    Only send what you want to change.
    """
    title: Optional[str] = Field(default=None, min_length=5)
    author: Optional[str] = Field(default=None, min_length=1)
    description: Optional[str] = Field(default=None, min_length=1, max_length=200)
    rating: Optional[int] = Field(default=None, gt=0, lt=6)
    published_date: Optional[int] = Field(default=None, gt=1999, lt=2030)
    price: Optional[float] = Field(default=None, gt=0)


class Book(BookBase):
    id: int = Field(description="Unique ID of the book")


class BookResponse(BaseModel):
    status: str
    data: Book


class BooksListResponse(BaseModel):
    status: str
    data: List[Book]


class MessageResponse(BaseModel):
    status: str
    message: str


# -------------------------------------------------------------------
# In-memory "database"
# -------------------------------------------------------------------

BOOKS: List[Book] = [
    Book(id=1, title='AI Engineering', author='Sam Johnson',
         description='Introduction to Artificial Intelligence',
         rating=5, published_date=2022, price=250.37),
    Book(id=2, title='Mastering Python', author='John Smith',
         description='Advanced Python programming techniques',
         rating=5, published_date=2020, price=199.99),
    Book(id=3, title='Data Science Fundamentals', author='Emily Carter',
         description='Core concepts of Data Science',
         rating=4, published_date=2019, price=180.50),
    Book(id=4, title='Machine Learning Basics', author='Andrew Miles',
         description='Beginner guide to Machine Learning',
         rating=4, published_date=2021, price=210.00),
    Book(id=5, title='Deep Learning Illustrated', author='Sophia Ray',
         description='Neural networks and deep learning concepts',
         rating=5, published_date=2023, price=299.99),
    Book(id=6, title='SQL for Analysts', author='David Brown',
         description='SQL mastery for data professionals',
         rating=5, published_date=2021, price=175.75),
    Book(id=7, title='Cloud Computing Essentials', author='Ravi Kumar',
         description='Introduction to cloud platforms',
         rating=4, published_date=2020, price=225.40),
    Book(id=8, title='Cyber Security 101', author='Alan Turing',
         description='Basics of cyber security and protection',
         rating=4, published_date=2018, price=160.00),
    Book(id=9, title='Big Data Analytics', author='Nina Patel',
         description='Understanding big data tools and techniques',
         rating=5, published_date=2022, price=285.20),
    Book(id=10, title='The Power of Algorithms', author='Grace Hopper',
         description='In-depth analysis of algorithms',
         rating=5, published_date=2017, price=195.99),
    Book(id=11, title='Natural Language Processing', author='James Allen',
         description='Text processing and AI communication',
         rating=4, published_date=2023, price=260.49),
    Book(id=12, title='Python for Finance', author='Michael Bloom',
         description='Using Python in financial analysis',
         rating=4, published_date=2019, price=215.60),
    Book(id=13, title='Web Development Bootcamp', author='Laura King',
         description='Frontend and backend web technologies',
         rating=5, published_date=2021, price=245.00),
    Book(id=14, title='DevOps Handbook', author='Chris Martin',
         description='CI/CD and automation with DevOps',
         rating=5, published_date=2022, price=320.75),
    Book(id=15, title='Prompt Engineering Guide', author='Daniel Roth',
         description='How to write effective AI prompts',
         rating=5, published_date=2023, price=150.25),
]


# -------------------------------------------------------------------
# Helper functions
# -------------------------------------------------------------------

def get_book_index_by_id(book_id: int) -> int:
    for idx, book in enumerate(BOOKS):
        if book.id == book_id:
            return idx
    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail=f"Book with id={book_id} not found",
    )


def generate_new_id() -> int:
    if not BOOKS:
        return 1
    return max(book.id for book in BOOKS) + 1


# -------------------------------------------------------------------
# Global health check
# -------------------------------------------------------------------

@app.get("/health", response_model=MessageResponse, status_code=status.HTTP_200_OK)
def health_check():
    """
    Simple health check endpoint.
    """
    return {"status": "ok", "message": "Service is healthy"}


# -------------------------------------------------------------------
# Read endpoints
# -------------------------------------------------------------------

@app.get(
    "/books",
    response_model=BooksListResponse,
    status_code=status.HTTP_200_OK,
)
def get_all_books(
    rating: Optional[int] = None,
    author: Optional[str] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None,
):
    """
    Get all books, with optional filters:
    - rating
    - author (case-insensitive contains)
    - min_price, max_price
    """
    try:
        results = BOOKS

        if rating is not None:
            results = [b for b in results if b.rating == rating]

        if author is not None:
            author_lower = author.lower()
            results = [b for b in results if author_lower in b.author.lower()]

        if min_price is not None:
            results = [b for b in results if b.price >= min_price]

        if max_price is not None:
            results = [b for b in results if b.price <= max_price]

        return {"status": "success", "data": results}
    except Exception as e:
        logger.exception("Error while fetching books")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Unexpected error while fetching books",
        ) from e


@app.get(
    "/books/{book_id}",
    response_model=BookResponse,
    status_code=status.HTTP_200_OK,
)
def get_book_by_id(book_id: int):
    """
    Get a single book by its ID.
    """
    try:
        idx = get_book_index_by_id(book_id)
        return {"status": "success", "data": BOOKS[idx]}
    except HTTPException:
        # Just re-raise 404
        raise
    except Exception as e:
        logger.exception("Error while fetching book by id")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Unexpected error while fetching book",
        ) from e


@app.get(
    "/books/rating/{rating}",
    response_model=BooksListResponse,
    status_code=status.HTTP_200_OK,
)
def get_books_by_rating(rating: int):
    """
    Get all books with a specific rating.
    """
    if rating < 1 or rating > 5:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Rating must be between 1 and 5",
        )

    try:
        filtered = [b for b in BOOKS if b.rating == rating]
        return {"status": "success", "data": filtered}
    except Exception as e:
        logger.exception("Error while fetching books by rating")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Unexpected error while fetching books by rating",
        ) from e


# -------------------------------------------------------------------
# Create endpoint
# -------------------------------------------------------------------

@app.post(
    "/books",
    response_model=BookResponse,
    status_code=status.HTTP_201_CREATED,
)
def create_book(payload: BookCreate):
    """
    Create a new book.
    - If id is provided and already exists -> 400
    - If id is missing -> auto-generate
    """
    try:
        # If client provided an ID, check uniqueness
        if payload.id is not None:
            if any(b.id == payload.id for b in BOOKS):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Book with id={payload.id} already exists",
                )
            new_id = payload.id
        else:
            new_id = generate_new_id()

        new_book = Book(id=new_id, **payload.model_dump(exclude={"id"}))
        BOOKS.append(new_book)
        logger.info("Created new book with id=%s", new_book.id)

        return {"status": "created", "data": new_book}
    except HTTPException:
        raise
    except Exception as e:
        logger.exception("Error while creating book")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Unexpected error while creating book",
        ) from e


# -------------------------------------------------------------------
# Update endpoints
# -------------------------------------------------------------------

@app.put(
    "/books/{book_id}",
    response_model=BookResponse,
    status_code=status.HTTP_200_OK,
)
def replace_book(book_id: int, payload: BookBase):
    """
    Full replacement of a book.
    All fields will be overwritten.
    """
    try:
        idx = get_book_index_by_id(book_id)
        updated_book = Book(id=book_id, **payload.model_dump())
        BOOKS[idx] = updated_book
        logger.info("Replaced book with id=%s", book_id)

        return {"status": "updated", "data": updated_book}
    except HTTPException:
        raise
    except Exception as e:
        logger.exception("Error while replacing book")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Unexpected error while replacing book",
        ) from e


@app.patch(
    "/books/{book_id}",
    response_model=BookResponse,
    status_code=status.HTTP_200_OK,
)
def update_book_partially(book_id: int, payload: BookUpdate):
    """
    Partial update of a book.
    Only provided fields will be updated.
    """
    try:
        idx = get_book_index_by_id(book_id)
        stored_book = BOOKS[idx]

        update_data = payload.model_dump(exclude_unset=True)
        updated_book_data = stored_book.model_dump()
        updated_book_data.update(update_data)

        updated_book = Book(**updated_book_data)
        BOOKS[idx] = updated_book
        logger.info("Partially updated book with id=%s", book_id)

        return {"status": "updated", "data": updated_book}
    except HTTPException:
        raise
    except Exception as e:
        logger.exception("Error while partially updating book")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Unexpected error while partially updating book",
        ) from e


# -------------------------------------------------------------------
# Delete endpoint
# -------------------------------------------------------------------

@app.delete(
    "/books/{book_id}",
    response_model=MessageResponse,
    status_code=status.HTTP_200_OK,
)
def delete_book(book_id: int):
    """
    Delete a book by ID.
    """
    try:
        idx = get_book_index_by_id(book_id)
        deleted_book = BOOKS.pop(idx)
        logger.info("Deleted book with id=%s", deleted_book.id)

        return {
            "status": "deleted",
            "message": f"Book with id={book_id} deleted successfully",
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.exception("Error while deleting book")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Unexpected error while deleting book",
        ) from e
